* Otus Course Notes
** Build Systems
*** CMAKE
**** CMAKE tipps and tricks
[[https://habr.com/en/articles/330902/][10 Advices on CMAKE]]
+ CMAKE Functions

#+begin_comment

function(custom_enable_cxx17 TARGET)
    target_compile_features(${TARGET} PUBLIC cxx_std_17)
    if (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
        set_target_properties(${TARGET} PROPERTIES COMPILE_FLAGS "/std:c++latest")
    elseif (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
        set_target_properties(${TARGET} PROPERTIES COMPILE_FLAGS "-stdlib=libc++ -pthread")
        target_link_libraries(${TARGET} c++experimental pthread)
    endif()
endfunction(custom_enable_cxx17)
#+end_comment

pro: Local usage of custom target macros etc.
contra: Tend to screw the visibility of bigger projects

+ CMAKE Command Line Tool
[[https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool][Run a Command-]]
*** Conan
+ run debug / release
  #+begin_src Shell
        conan install . --output-folder=build --build=missing --settings=build_type=Debug
        conan install . --output-folder=build --build=missing --settings=build_type=Realease
  #+end_src

** CI/CD
** Auto , lambda , tuple
*** Lambda expressions
**** Lambda expressions without an explicit template parameter list
Basic syntax [captures](params){boby}
- captures
#+begin_src C++ :includes '(<iostream> <algorithm> <functional>) :main no :flags -std=c++20 :results output
  using namespace std;
  float vf0[5] = {1.2, 3.4, 5.1, 8.4, 9.9};
  function<void(float&)> out = [](float &f) {
      cout << f << ' ';
  };
  for_each(vf0, vf0+5, out);
#+end_src

#+RESULTS:

**** lambda expr with explicit template param list
*** Auto
**** Exercise
#+begin_src C++ :includes '(<iostream> <typeinfo>) :namespaces std :main no :flags -std=c++17 :results output
template <typename T>
void func1(T param) {
   cout << "Func 1 param : " <<  typeid(param).name() << endl;
}
template <typename T>
void func2(T& param) {
   cout << "Func 2 param : " <<  typeid(param).name() << endl;
}
template <typename T>
void func3(T* param) {

}
template <typename T>
void func4(T&& param) {

}

int  main(){
    int i = 10;
    const int ci = 15;
    const int &cir = ci;
    int * pi = &i;
    const int * cpi = &i;

    func1(i);
    func2(ci);
}

#+end_src

#+RESULTS:
: Func 1 param : i
: Func 2 param : i

*** Tuple
#+begin_quote
Tupple defenition
Class template std::tuple is a fixed-size collection of heterogeneous values. It is a generalization of std::pair.
If std::is_trivially_destructible<Ti>::value is true for every Ti in Types, the destructor of std::tuple is trivial.

#+end_quote

#+begin_src C++  :includes <iostream> <string> <tuple> :flags -std=c++17 :main no :results output
using namespace std;
tuple<double, char,string> get_student(int id ){
    switch (id) {
        case 0: return {3.8, 'A', "Lisa Simpson"};
        case 1: return {2.9, 'C', "Milhouse Van Houten"};
        case 2: return {1.7, 'D', "Ralph Wiggum"};
        case 3: return {0.6, 'F', "Bart Simpson"};
        }
    throw std::invalid_argument("id");
    }

int main()
{
    const auto student0 = get_student(0);
    std::cout << "ID: 0, "
              << "GPA: " << std::get<0>(student0) << ", "
              << "grade: " << std::get<1>(student0) << ", "
              << "name: " << std::get<2>(student0) << '\n';

    const auto student1 = get_student(1);
    std::cout << "ID: 1, "
              << "GPA: " << std::get<double>(student1) << ", "
              << "grade: " << std::get<char>(student1) << ", "
              << "name: " << std::get<std::string>(student1) << '\n';

    double gpa2;
    char grade2;
    string name2;
    tie(gpa2, grade2, name2) = get_student(2);
    cout << "ID: 2, "
              << "GPA: " << gpa2 << ", "
              << "grade: " << grade2 << ", "
              << "name: " << name2 << '\n';

    // C++17 structured binding:
    const auto [gpa3, grade3, name3] = get_student(3);
    cout << "ID: 3, "
              << "GPA: " << gpa3 << ", "
              << "grade: " << grade3 << ", "
              << "name: " << name3 << '\n';
}

#+end_src

#+RESULTS:
: ID: 0, GPA: 3.8, grade: A, name: Lisa Simpson
: ID: 1, GPA: 2.9, grade: C, name: Milhouse Van Houten
: ID: 2, GPA: 1.7, grade: D, name: Ralph Wiggum
: ID: 3, GPA: 0.6, grade: F, name: Bart Simpson

+ exercise example
#+NAME: tuple example
#+begin_src C++ :includes <string> <tuple> <cassert> <iostream> :flags -std=c++20 :results output :main no

using namespace std;
auto getPerson() {
        const string name = "Petia";
        const string secondName = "Ivanoff";
        const size_t age = 23;
        const string department = "Sale";
        return make_tuple(name, secondName, age, department);
}

template<typename... Args,typename Func>
auto custom_tie(Args&&... args,Func func){
    auto result = func();
    auto[name,secondName,age,department] = result;
    tie(args...) = forward<decltype(result)>(result);
}

int main(int argc, char * argv[]) {
        string name, secondName, department;
        size_t age;
        // Call custom_tie to assign values
        custom_tie(name, secondName, age, department) = getPerson();
        cout<< "Name : " << name << " Second  name : " << secondName << "department" << department << endl;

        assert(name == "Petia");
        assert(secondName == "Ivanoff");
        assert(age == 23);
        assert(department == "Sale");
return 0;
}

#+end_src

#+RESULTS: tuple example

** Move, variadic templates
*** Move
#+begin_quote
In C++11, std::move is a standard library function that casts (using static_cast) its argument into an r-value reference, so that move semantics can be invoked. Thus, we can use std::move to cast an l-value into a type that will prefer being moved over being copied. std::move is defined in the utility header.
#+end_quote

*** Variadic templates
#+begin_src C++

#+end_src

** Literal / Chrono
***  Custom literal
#+begin_src C++
auto a = 42_kg;
// operator "" _kg(unsigned long long value)

#+end_src

** Constexpr
** Autopointer
*** RAII Resource aquisition is initialisation
#+begin_quote
RAII Resource acquisition is initialization (RAII)[1] is a programming idiom[2] used in several object-oriented, statically typed programming languages to describe a particular language behavior. In RAII, holding a resource is a class invariant, and is tied to object lifetime. Resource allocation (or acquisition) is done during object creation (specifically initialization), by the constructor, while resource deallocation (release) is done during object destruction (specifically finalization), by the destructor. In other words, resource acquisition must succeed for initialization to succeed. Thus the resource is guaranteed to be held between when initialization finishes and finalization starts (holding the resources is a class invariant), and to be held only when the object is alive. Thus if there are no object leaks, there are no resource leaks.
#+end_quote

#+begin_src C++ :includes '(<iostream> <algorithm> <functional>) :main no :flags -std=c++20 :results output
void WriteToFile(const std::string& message) {
  // |mutex| is to protect access to |file| (which is shared across threads).
  static std::mutex mutex;

  // Lock |mutex| before accessing |file|.
  std::lock_guard<std::mutex> lock(mutex);

  // Try to open file.
  std::ofstream file("example.txt");
  if (!file.is_open()) {
    throw std::runtime_error("unable to open file");
  }

  // Write |message| to |file|.
  file << message << std::endl;

}
#+end_src

*** CRTP
#+begin_quote
The curiously recurring template pattern (CRTP) is an idiom, originally in C++, in which a class X derives from a class template instantiation using X itself as a template argument.[1] More generally it is known as F-bound polymorphism, and it is a form of F-bounded quantification.
#+end_quote

**** Polymorphic chaining
#+begin_src C++ :includes '(<iostream> <algorithm> <functional>) :main no :flags -std=c++20 :results output
class Printer
{
public:
    Printer(ostream& pstream) : m_stream(pstream) {}

    template <typename T>
    Printer& print(T&& t) { m_stream << t; return *this; }

    template <typename T>
    Printer& println(T&& t) { m_stream << t << endl; return *this; }
private:
    ostream& m_stream;
};

class CoutPrinter : public Printer
{
public:
    CoutPrinter() : Printer(cout) {}

    CoutPrinter& SetConsoleColor(Color c)
    {
        // ...
        return *this;
    }
};
#+end_src

*** Weak ptr

#+begin_src C++ :includes '(<iostream> <algorithm> <functional> <cassert>) :main no :flags -std=c++20 :results output
using namespace std;

struct Observer {
  public:
    explicit Observer(int value) : m_value(value) {}

    void notify() { std::cout << "notify: " << m_value << std::endl; }

  private:
    int m_value;
};

struct Observable {
    void registerObserver(const std::shared_ptr<Observer> &observer) {
        m_observers.emplace_back(observer);
    }

    void notify() {
        for (auto &obs : m_observers) {
            auto ptr = obs;
            auto p = ptr.lock();
            if (p)
                p->notify();
        }
    }

  private:
    std::vector<std::weak_ptr<Observer>> m_observers;
};

void observer_test() {
    Observable observable;
    auto obs1 = make_shared<Observer>(1);
    observable.registerObserver(obs1);

    auto obs2 = make_shared<Observer>(2);
    observable.registerObserver(obs2);

    auto obs3 = make_shared<Observer>(3);
    observable.registerObserver(obs3);

    {
        auto obs4 = make_shared<Observer>(4);
        observable.registerObserver(obs4);
    }

    observable.notify();
}

void weak_ptr_example() {
    weak_ptr<int> weak;
    {
        auto shared = make_shared<int>(42);
        weak = shared;
        auto x = weak.lock();
        assert(x);
    }
    auto x = weak.lock();
    assert(!x);
}

int main() {

    weak_ptr_example();
    observer_test();

    return 0;
}

#+end_src

#+RESULTS:
: notify: 1
: notify: 2
: notify: 3

*** Smart ptr

#+begin_src C++ :includes '(<iostream> <algorithm> <functional> <cassert>) :main no :flags -std=c++20 :results output

#include <iostream>

template <typename T>
class smart_ptr {
    T *ptr;

  public:
    smart_ptr(T *ptr_) : ptr{ptr_} {}
    ~smart_ptr() { delete ptr; }
    T *get() { return ptr; }
    T *operator->() { return ptr; }
    T &operator*() { return *ptr; }
};

class A {
  public:
    A() { std::cout << __PRETTY_FUNCTION__ << std::endl; }
    ~A() { std::cout << __PRETTY_FUNCTION__ << std::endl; }
};

void example() {
    smart_ptr<int> ptr(new int{10});
}

template <typename T>
void foo(smart_ptr<T> ptr) {
    std::cout << ptr.get() << std::endl;
}

void double_free() {
    std::cout << __PRETTY_FUNCTION__ << std::endl;
    smart_ptr<A> ptr(new A);
}


void double_free2() {
    std::cout << __PRETTY_FUNCTION__ << std::endl;
    smart_ptr<A> ptr(new A);
    foo(ptr);
}

int main() {

    double_free();
    double_free2();
    return 0;
}
#+end_src

#+RESULTS:
: void double_free()
: A::A()
: A::~A()
: void double_free2()
: A::A()
: 0x600000f30030
: A::~A()
: A::~A()

** Allocator
Allocator could be used for:

- Impl. Memory allocation strategy
- Custom memory allocation for example on GPU
- Memory allocation tracing counting
- Avoiding memory fragmentation
- Special environments , embeded systems etc.


***  Simple Allocator
#+begin_quote
The std::allocator class template is the default Allocator used by all standard library containers if no user-specified allocator is provided. The default allocator is stateless, that is, all instances of the given allocator are interchangeable, compare equal and can deallocate memory allocated by any other instance of the same allocator type.
#+end_quote

**** Defalut allocator behavior
- Stateless
- Allocate
- Deallocate
- Destroy
**** Allocator evolution overview

| C++03              | c++ 11      |
| 7 Typedefs         | 1 Typedef   |
| 2 Ctor             | 2 Ctor      |
| 2 Op               | 2 Op        |
| 7 functions        | 2 Functions |
| 1 Embeded Template |             |

The reduction of the boilerplate code is achieved through the usage of std::allocator_traits  abstraction layer


**** Stateless Allocator

#+NAME: Allocator Template
#+begin_src C++ :includes <iostream> <algorithm> <vector> <memory> <map> :main no :flags -std=c++20 :results output

template <class T>
struct std_03_allocator {
    typedef T value_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T& reference;
    typedef const T& const_reference;

    std_03_allocator () noexcept {}
    template <class U> std_03_allocator  (const std_03_allocator <U>&) noexcept {}

    T* allocate (std::size_t n)
    {
        return static_cast<T*>(::operator new(n*sizeof(T)));
    }
    void deallocate (T* p, std::size_t n)
    {
        ::operator delete(p);
    }

    template <class Up, class... Args>
    void construct(Up* p, Args&&... args) {
        ::new ((void*)p) Up(std::forward<Args>(args)...);
    }

    void destroy(pointer p) {
        p->~T();
    }

    template< class U >
    struct rebind
    {
        typedef std_03_allocator<U> other;
    };
};

#+end_src





* Assignmenst
** IP Filter
–†–µ–∞–ª–∏–∑—É–µ–º —É—Ç–∏–ª–∏—Ç—É –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–π —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ª–æ–≥–∞ IP-–∞–¥—Ä–µ—Å–æ–≤. –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å–±–æ—Ä–æ—á–Ω–æ–π —Ñ–µ—Ä–º–æ–π –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –ø–∞–∫–µ—Ç–∞.
–ü—Ä–æ–≥—Ä–∞–º–º–∞ –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ –≤–≤–æ–¥–∞ —á–∏—Ç–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ. –î–∞–Ω–Ω—ã–µ —Ö—Ä–∞–Ω—è—Ç—Å—è –ø–æ—Å—Ç—Ä–æ—á–Ω–æ. –ö–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞ —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ —Ç—Ä–µ—Ö –ø–æ–ª–µ–π, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö –æ–¥–Ω–∏–º —Å–∏–º–≤–æ–ª–æ–º —Ç–∞–±—É–ª—è—Ü–∏–∏, –∏ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è —Å–∏–º–≤–æ–ª–æ–º –∫–æ–Ω—Ü–∞ —Å—Ç—Ä–æ–∫–∏.
–§–æ—Ä–º–∞—Ç —Å—Ç—Ä–æ–∫–∏:
text1 \t text2 \t text3 \n

–ü–æ–ª—è text2 –∏ text3 –∏–≥–Ω–æ—Ä–∏—Ä—É—é—Ç—Å—è. –ü–æ–ª–µ text1 –∏–º–µ–µ—Ç —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É (ip4 address):
n1.n2.n3.n4
–≥–¥–µ n1..4 ‚Äì —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –æ—Ç 0 –¥–æ 255.

–¢—Ä–µ–±—É–µ—Ç—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ ip-–∞–¥—Ä–µ—Å–æ–≤ –≤ –ø–∞–º—è—Ç—å –∏ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∏—Ö –≤ –æ–±—Ä–∞—Ç–Ω–æ–º
–ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–º –ø–æ—Ä—è–¥–∫–µ. –ü—Ä–∏–º–µ—Ä –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–π —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ (–ø–æ –ø–µ—Ä–≤–æ–º—É —á–∏—Å–ª—É, –∑–∞—Ç–µ–º –ø–æ –≤—Ç–æ—Ä–æ–º—É –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ):

1.1.1.1
1.2.1.1
1.10.1.1

–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ, –æ–±—Ä–∞—Ç–Ω–∞—è:

1.10.1.1
1.2.1.1
1.1.1.1

#+begin_quote

üí°
–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ ‚Äì —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤ –±–∞–π—Ç–æ–≤–æ–º (—á–∏—Å–ª–µ–Ω–Ω–æ–º) –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–∏ IP-–∞–¥—Ä–µ—Å–∞, –∞ –Ω–µ –≤ —Å—Ç—Ä–æ–∫–æ–≤–æ–º. –ü–æ—ç—Ç–æ–º—É –∞–¥—Ä–µ—Å, –Ω–∞–ø—Ä–∏–º–µ—Ä, 1.2.1.1 –º–µ–Ω—å—à–µ –∞–¥—Ä–µ—Å–∞ 1.10.1.1 (–≤–µ–¥—å 2 < 10).
–î–∞–ª–µ–µ –≤—ã–≤–æ–¥–∏–º –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã–≤–æ–¥ —Å–ª–µ–¥—É—é—â–µ–µ:
–ü–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∞–¥—Ä–µ—Å–æ–≤ –ø–æ—Å–ª–µ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏. –û–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ - –æ–¥–∏–Ω –∞–¥—Ä–µ—Å.
–°—Ä–∞–∑—É —Å–ª–µ–¥–æ–º —Å–ø–∏—Å–æ–∫ –∞–¥—Ä–µ—Å–æ–≤, –ø–µ—Ä–≤—ã–π –±–∞–π—Ç –∫–æ—Ç–æ—Ä—ã—Ö —Ä–∞–≤–µ–Ω 1. –ü–æ—Ä—è–¥–æ–∫ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è.
–û–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ - –æ–¥–∏–Ω –∞–¥—Ä–µ—Å. –°–ø–∏—Å–∫–∏ –Ω–∏—á–µ–º –Ω–µ —Ä–∞–∑–¥–µ–ª—è—é—Ç—Å—è.
–°—Ä–∞–∑—É –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è —Å–ø–∏—Å–æ–∫ –∞–¥—Ä–µ—Å–æ–≤, –ø–µ—Ä–≤—ã–π –±–∞–π—Ç –∫–æ—Ç–æ—Ä—ã—Ö —Ä–∞–≤–µ–Ω 46, –∞ –≤—Ç–æ—Ä–æ–π 70. –ü–æ—Ä—è–¥–æ–∫
—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è. –û–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ - –æ–¥–∏–Ω –∞–¥—Ä–µ—Å. –°–ø–∏—Å–∫–∏ –Ω–∏—á–µ–º –Ω–µ —Ä–∞–∑–¥–µ–ª—è—é—Ç—Å—è.
–°—Ä–∞–∑—É –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è —Å–ø–∏—Å–æ–∫ –∞–¥—Ä–µ—Å–æ–≤, –ª—é–±–æ–π –±–∞–π—Ç –∫–æ—Ç–æ—Ä—ã—Ö —Ä–∞–≤–µ–Ω 46. –ü–æ—Ä—è–¥–æ–∫ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –Ω–µ
–º–µ–Ω—è–µ—Ç—Å—è. –û–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ - –æ–¥–∏–Ω –∞–¥—Ä–µ—Å. –°–ø–∏—Å–∫–∏ –Ω–∏—á–µ–º –Ω–µ —Ä–∞–∑–¥–µ–ª—è—é—Ç—Å—è.

#+end_quote

*** –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

–í –ø—Ä–∏–ª–æ–∂–µ–Ω–Ω–æ–º –∫ –∑–∞–¥–∞–Ω–∏—é –∏—Å—Ö–æ–¥–Ω–æ–º —Ñ–∞–π–ª–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞–º–µ–Ω–∏—Ç—å, –≥–¥–µ —ç—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ,
–∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –Ω–∞ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–µ –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞ –°++14/C++17. –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª.
–ù–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Å–ª–µ–¥–æ–≤–∞—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–Ω–æ–º—É —à–∞–±–ª–æ–Ω—É. –ú–æ–∂–Ω–æ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ, –æ—Ñ–æ—Ä–º–∏–≤ –∫–æ–¥
–ª—é–±—ã–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º.
–õ–∏—à–Ω–∏–π —Ä–∞–∑ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ
–ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ–Ω—è—Ç–Ω–∞ –∫–∞–∫ –¥–ª—è —Å—Ç—Ä–æ–∫–∏, —Ç–∞–∫ –∏ –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
–≤—ã–±—Ä–∞–Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∞—è –∑–∞–¥–∞—á–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
–°–∞–º–æ–ø—Ä–æ–≤–µ—Ä–∫–∞

–ú–∞–∫–µ—Ç –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞, –∞ —Ç–∞–∫–∂–µ —Ç–µ—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª —Å –¥–∞–Ω–Ω—ã–º–∏ ip_filter.tsv –ø—Ä–∏–ª–∞–≥–∞–µ—Ç—Å—è –∫ –º–∞—Ç–µ—Ä–∏–∞–ª–∞–º
–∑–∞–Ω—è—Ç–∏—è. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–µ–±—è –º–æ–∂–Ω–æ —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º (Linux):

cat ip_filter.tsv | ip_filter | md5sum

24e7a7b2270daee89c64d3ca5fb3da1a -

** Allocator
*** –†–µ–∞–ª–∏–∑—É–µ–º —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π STL-—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π –∞–ª–ª–æ–∫–∞—Ç–æ—Ä, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞—Ö. –ü–∏—à–µ–º —Å–≤–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–∞—Ü–∏—é –∞–ª–ª–æ–∫–∞—Ç–æ—Ä–æ–º –ø–æ –∞–Ω–∞–ª–æ–≥–∏–∏ —Å STL.

–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–≤–æ–π –∞–ª–ª–æ–∫–∞—Ç–æ—Ä –ø–∞–º—è—Ç–∏, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª–∏—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é —Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏. –î–∞–ª–µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–æ—Ç –∞–ª–ª–æ–∫–∞—Ç–æ—Ä —Å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–º std::map.
–ê–ª–ª–æ–∫–∞—Ç–æ—Ä –¥–æ–ª–∂–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –≤—ã–¥–µ–ª—è–µ–º—ã—Ö –∑–∞ —Ä–∞–∑ —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –Ω–µ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è - –∞–ª–ª–æ–∫–∞—Ç–æ—Ä –¥–æ–ª–∂–µ–Ω –æ—Å–≤–æ–±–æ–∂–¥–∞—Ç—å –≤—Å—é –ø–∞–º—è—Ç—å —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ.
–ê–ª–ª–æ–∫–∞—Ç–æ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç —Å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –ü–æ–ø—ã—Ç–∫—É –≤—ã–¥–µ–ª–∏—Ç—å –±–æ–ª—å—à–µ–µ —á–∏—Å–ª–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å—á–∏—Ç–∞—Ç—å –æ—à–∏–±–∫–æ–π.
–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ä–∞—Å—à–∏—Ä—è–µ–º–æ—Å—Ç—å –∞–ª–ª–æ–∫–∞—Ç–æ—Ä–∞. –ü—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –≤—ã–¥–µ–ª–∏—Ç—å —á–∏—Å–ª–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –∫–æ—Ç–æ—Ä–æ–µ –ø—Ä–µ–≤—ã—à–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ, –∞–ª–ª–æ–∫–∞—Ç–æ—Ä —Ä–∞—Å—à–∏—Ä—è–µ—Ç –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω–Ω—É—é –ø–∞–º—è—Ç—å.
–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ—ç–ª–µ–º–µ–Ω—Ç–Ω–æ–µ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ.

**** –¶–µ–ª—å —Ç–∞–∫–æ–≥–æ –∞–ª–ª–æ–∫–∞—Ç–æ—Ä–∞ ‚Äì —Å–Ω–∏–∑–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø–µ—Ä–∞—Ü–∏–π –≤—ã–¥–µ–ª–µ–Ω–∏—è –ø–∞–º—è—Ç–∏.
–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–≤–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–æ –∞–Ω–∞–ª–æ–≥–∏–∏ —Å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞–º–∏ stl –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑—É–µ—Ç—Å—è
–∞–ª–ª–æ–∫–∞—Ç–æ—Ä–æ–º. –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å –¥–≤–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ - –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏ –æ–±–æ–π—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –≤ –æ–¥–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏.
–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞–º–∏ stl ‚Äì –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã, –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã size, empty –∏ —Ç.–¥.

**** –¶–µ–ª—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–≤–æ–µ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ ‚Äì –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å std::allocator, –∞ —Ç–∞–∫–∂–µ —Å–≤–æ–π –∞–ª–ª–æ–∫–∞—Ç–æ—Ä.

**** –ü—Ä–∏–∫–ª–∞–¥–Ω–æ–π –∫–æ–¥ –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ –≤—ã–∑–æ–≤—ã:

- —Å–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ std::map<int, int>
- –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ 10 —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏, –≥–¥–µ –∫–ª—é—á - —ç—Ç–æ —á–∏—Å–ª–æ –æ—Ç 0 –¥–æ 9, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ - —Ñ–∞–∫—Ç–æ—Ä–∏–∞–ª –∫–ª—é—á–∞
- —Å–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ std::map<int, int> —Å –Ω–æ–≤—ã–º –∞–ª–ª–æ–∫–∞—Ç–æ—Ä–æ–º, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–º 10 —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
- –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ 10 —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏, –≥–¥–µ –∫–ª—é—á - —ç—Ç–æ —á–∏—Å–ª–æ –æ—Ç 0 –¥–æ 9, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ - —Ñ–∞–∫—Ç–æ—Ä–∏–∞–ª –∫–ª—é—á–∞
- –≤—ã–≤–æ–¥ –Ω–∞ —ç–∫—Ä–∞–Ω –≤—Å–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π (–∫–ª—é—á –∏ –∑–Ω–∞—á–µ–Ω–∏–µ —Ä–∞–∑–¥–µ–ª–µ–Ω—ã –ø—Ä–æ–±–µ–ª–æ–º) —Ö—Ä–∞–Ω—è—â–∏—Ö—Å—è –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ
- —Å–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —Å–≤–æ–µ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ int
- –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ 10 —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ –æ—Ç 0 –¥–æ 9
- —Å–æ–∑–¥–∞–Ω–∏–µ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —Å–≤–æ–µ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π —Ç–∏–ø–∞ int —Å –Ω–æ–≤—ã–º –∞–ª–ª–æ–∫–∞—Ç–æ—Ä–æ–º, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–º 10 —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
- –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ 10 —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ –æ—Ç 0 –¥–æ 9
- –≤—ã–≤–æ–¥ –Ω–∞ —ç–∫—Ä–∞–Ω –≤—Å–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π, —Ö—Ä–∞–Ω—è—â–∏—Ö—Å—è –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ
